<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension="" #>
//TODO Merge string info arrays into a single structure
//TODO Automate generation of typeVectorConstructorArguments
<#	var typeSizes = new string[] {"32"}; 
	var vectorSizes = new string[] {"128", "256"};

	var typeVectorConstructorArguments = new string[,] {{"int32_t v1, int32_t v2, int32_t v3, int32_t v4"},
													    {"int32_t v1, int32_t v2, int32_t v3, int32_t v4, int32_t v5, int32_t v6, int32_t v7, int32_t v8"}}; #>
#ifndef VECTOR_H
#define VECTOR_H
#include <intrin.h>
#include <sstream>

//TODO Check if these are needed in the header, same for the constraints in general										
template <uint_fast16_t X>
_INLINE_VAR constexpr bool is_simd_128 = X == 128;

template <uint_fast16_t X>
_INLINE_VAR constexpr bool is_simd_256 = X == 256;

template<typename T, uint_fast16_t X>
struct vector
{
	friend class VectorHelpers;

private:
	__m128i vector_128_{};
	__m256i vector_256_{};

	//TODO Generate automatically?
	vector(__m128i vector);

	vector(__m256i vector);

public:
<#	for (int i = 0; i < vectorSizes.Length; i++)
	{
		//Required variables
		string vectorSize = vectorSizes[i];

		//Niceties
		string vectorVariableName = "vector_" + vectorSize + "_";

		for (int j = 0; j < typeSizes.Length; j++)
		{ 
			//Required variables
			string typeSize = typeSizes[j], typeVectorConstructorArgument = typeVectorConstructorArguments[i,j];
			
			//Niceties
			string typeName = "int" + typeSize + "_t", fullVectorName = "vector<" + typeName + ", " + vectorSize + ">";
			string typeVectorConstraints = "requires(std::is_same_v<T, " + typeName + "> && is_simd_" + vectorSize + "<X>)";#>
	#pragma region <#= fullVectorName #>

	// Constructors
	vector(<#= typeName #> value) <#= typeVectorConstraints #>;

	explicit vector(<#= typeVectorConstructorArgument #>) <#= typeVectorConstraints #>;

	//TODO Figure out how to make the types of the parameters enough to figure out which version to use and not require specifying when accessing vector
	<#= fullVectorName #> static Blend(<#= fullVectorName #> comparision, <#= fullVectorName #> falseValue, <#= fullVectorName #> trueValue);

	// Assignment Operators
	vector& operator+=(const <#= fullVectorName #>& rhs);

	// Comparision Operators
	//TODO Fix this not working allow implicit casts when more than one version exist
	<#= fullVectorName #> operator>(const <#= fullVectorName #>& vector2) const;
	
	#pragma endregion
<#		}
	} #>
};

#ifndef _DEVELOPMENT
#include "Vector.cpp"
#endif
#endif //VECTOR_H