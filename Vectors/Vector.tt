<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cpp" #>
//TODO Merge string info arrays into a single structure
<#	var typeSizes = new string[] {"32"}; 
	var vectorSizes = new string[] {"128"};

	var typeVectorConstructorArguments = new string[,] {{"const int32_t v1, const int32_t v2, const int32_t v3, const int32_t v4"}};
	var typeVectorSetArguments = new string[,] {{"v1, v2, v3, v4"}};

	var vectorSimdPrefixes = new string[] {"mm"};
	var typeSimdSuffixes = new string[] {"32"}; #>
#include <intrin.h>

template <uint_fast16_t X>
_INLINE_VAR constexpr bool is_simd_128 = X == 128;

template<typename T, uint_fast16_t X>
struct vector
{
private:
	__m128i vector_128_{};

	//TODO Generate automatically?
	vector(const __m128i vector) : vector_128_(vector)
	{
	}

public:
	[[nodiscard]] std::string ToString128i() const
	{
		std::stringstream sstr;
		T values[16 / sizeof(T)];
		std::memcpy(values, &this->vector_128_, sizeof(values));

		for (T v : values)
		{
			sstr << v << " ";
		}

		return sstr.str();
	}

<#	for (int i = 0; i < vectorSizes.Length; i++)
	{
		//Required variables
		string vectorSize = vectorSizes[i], vectorSimdPrefix = vectorSimdPrefixes[i];

		//Niceties
		string vectorVariableName = "vector_" + vectorSize + "_";

		for (int j = 0; j < typeSizes.Length; j++)
		{ 
			//Required variables
			string typeSize = typeSizes[j], typeVectorConstructorArgument = typeVectorConstructorArguments[i,j];
			string typeSimdSuffix = typeSimdSuffixes[j], typeVectorSetArgument = typeVectorSetArguments[i,j];
			
			//Niceties
			string typeName = "int" + typeSize + "_t", fullVectorName = "vector<" + typeName + ", " + vectorSize + ">";
			string typeVectorConstraints = "requires(std::is_same_v<T, " + typeName + "> && is_simd_" + vectorSize + "<X>)";#>
	#pragma region <#= fullVectorName #>

	// Constructors
	vector(const <#= typeName #> value) <#= typeVectorConstraints #> : <#= vectorVariableName #>(_<#= vectorSimdPrefix #>_set1_epi<#= typeSimdSuffix #>(value))
	{
	}

	explicit vector(<#= typeVectorConstructorArgument #>) <#= typeVectorConstraints #> : <#= vectorVariableName #>(_<#= vectorSimdPrefix #>_setr_epi<#= typeSimdSuffix #>(<#= typeVectorSetArgument #>))
	{
	}

	//TODO Figure out how to make the types of the parameters enough to figure out which version to use and not require specifying when accessing vector
	<#= fullVectorName #> static Blend(const <#= fullVectorName #> comparision, const <#= fullVectorName #> falseValue, const <#= fullVectorName #> trueValue)
	{
		return _<#= vectorSimdPrefix #>_blendv_epi8(falseValue.<#= vectorVariableName #>, trueValue.<#= vectorVariableName #>, comparision.<#= vectorVariableName #>);
	}

	// Assignment Operators
	vector& operator+=(const <#= fullVectorName #>& rhs)
	{
		this-><#= vectorVariableName #> = _<#= vectorSimdPrefix #>_add_epi<#= typeSize #>(this-><#= vectorVariableName #>, rhs.<#= vectorVariableName #>);
		return *this;
	}

	// Comparision Operators
	<#= fullVectorName #> operator>(const <#= fullVectorName #>& vector2) const
	{
		return _<#= vectorSimdPrefix #>_cmpgt_epi<#= typeSize #>(this-><#= vectorVariableName #>, vector2.<#= vectorVariableName #>);
	}
	#pragma endregion
<#		}
	} #>
};

//TODO Fix when adding non 128i types
// String/Stream Operators
<#	for (int i = 0; i < vectorSizes.Length; i++)
	{ 
		//Required variables
		string vectorSize = vectorSizes[i], vectorSimdPrefix = vectorSimdPrefixes[i];

		for (int j = 0; j < typeSizes.Length; j++)
		{ 
			//Required variables
			string typeSize = typeSizes[j];

			//Niceties
			string typeName = "int" + typeSize + "_t", fullVectorName = "vector<" + typeName + ", " + vectorSize + ">"; #>
inline std::ostream& operator<<(std::ostream& stream, const <#= fullVectorName #>& vector)
{
	return stream << vector.ToString128i();
}
<#		}
	} #>