<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension="" #>
//TODO Merge string info arrays into a single structure
//TODO Automate generation of typeVectorConstructorArguments
//TODO add _mm_empty for mmx operation call
<#	var typeSizes = new int[] {8}; 
	var vectorSizes = new int[] {64};

	var typeVectorSetArguments = new string[,] {{"values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7]"}};

	var vectorSimdPrefixes = new string[] {"mm"};
	var typeSimdSuffixes = new string[] {"pi8"}; #>
#include <sstream>
#include <string>
#include "Vector.h"

struct VectorHelpers
{
	//Vector ToString Functions
	//TODO Check if these can be merged, doubt it though given use of vector_{64, 128, 256}_, only works if GetInternal{64, 128, 256} can be merged as well
	template <typename T>
	static std::string ToString64i(const Vector<T, 64> vector)
	{
		std::stringstream sstr;
		T values[8 / sizeof(T)];
		std::memcpy(values, &vector.vector_64_, sizeof(values));

		for (T v : values)
		{
			sstr << static_cast<int>(v) << " ";
		}

		return sstr.str();
	}
	
	template <typename T>
	static std::string ToString128i(const Vector<T, 128> vector)
	{
		std::stringstream sstr;
		T values[16 / sizeof(T)];
		std::memcpy(values, &vector.vector_128_, sizeof(values));

		for (T v : values)
		{
			sstr << v << " ";
		}

		return sstr.str();
	}

	template <typename T>
	static std::string ToString256i(const Vector<T, 256> vector) 
	{
		std::stringstream sstr;
		T values[32 / sizeof(T)];
		std::memcpy(values, &vector.vector_256_, sizeof(values));

		for (T v : values)
		{
			sstr << v << " ";
		}

		return sstr.str();
	}

	//TODO Generate automatically?
	template <typename T>
	static __m128i GetInternal128i(const Vector<T, 128> vector)
	{
		return vector.vector_128_;
	}

	template <typename T>
	static __m256i GetInternal256i(const Vector<T, 256> vector)
	{
		return vector.vector_256_;
	}

	template <typename T>
	static Vector<T, 128> GetVector128i(const __m128i vector)
	{
		return vector;
	}

	template <typename T>
	static Vector<T, 256> GetVector256i(const __m256i vector)
	{
		return vector;
	}
};

<#	for (int i = 0; i < vectorSizes.Length; i++)
	{
		//Required variables
		int vectorSize = vectorSizes[i];
		string vectorSimdPrefix = vectorSimdPrefixes[i];

		//Niceties
		string vectorVariableName = "vector_" + vectorSize + "_";

		for (int j = 0; j < typeSizes.Length; j++)
		{ 
			//Required variables
			int typeSize = typeSizes[j];
			string typeSimdSuffix = typeSimdSuffixes[j], typeVectorSetArgument = typeVectorSetArguments[i,j];
			
			//Niceties
			string typeName = "int" + typeSize + "_t", typeVectorName = "Vector<" + typeName + ", " + vectorSize + ">"; #>
#pragma region <#= typeVectorName #>
// Constructors
template <>
<#= typeVectorName #>::Vector(const <#= typeName #> value) : <#= vectorVariableName #>(_<#= vectorSimdPrefix #>_set1_<#= typeSimdSuffix #>(value))
{
}

template <>
<#= typeVectorName #>::Vector(const std::array<<#= typeName #>, <#= vectorSize / typeSize #>> values) : <#= vectorVariableName #>(_<#= vectorSimdPrefix #>_setr_<#= typeSimdSuffix #>(<#= typeVectorSetArgument #>))
{
}

//TODO Fix for floating point types
std::ostream& operator<<(std::ostream& stream, const <#= typeVectorName #>& vector)
{
	return stream << VectorHelpers::ToString<#= vectorSize #>i(vector);
}

// Assignment Operators
template <>
<#= typeVectorName #>& <#= typeVectorName #>::operator+=(const <#= typeVectorName #>& rhs)
{
	this-><#= vectorVariableName #> = _<#= vectorSimdPrefix #>_add_<#= typeSimdSuffix #>(this-><#= vectorVariableName #>, rhs.<#= vectorVariableName #>);
	return *this;
}

// Comparision Operators
template <>
<#= typeVectorName #> <#= typeVectorName #>::operator>(const <#= typeVectorName #>& vector2) const
{
	return _<#= vectorSimdPrefix #>_cmpgt_<#= typeSimdSuffix #>(this-><#= vectorVariableName #>, vector2.<#= vectorVariableName #>);
}
#pragma endregion

<#		}
	} #>